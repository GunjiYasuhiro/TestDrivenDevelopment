package chapter02_DegenerateObjects;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

class MoneyTest {
	@Test
	void testMultiplication() {
		Dollar five = new Dollar(5);
		Dollar product = five.times(2);
		assertEquals(10, product.amount);
		product = five.times(3);
		assertEquals(15, product.amount);
	}
}

/*

一般的なTDDのサイクルは以下
１．テストを書く。
	頭の中で想像した操作がどんなコードとして現れるかを考える
	今あなたは物語を書いている。
	欲しいと思うインターフェースを創作しよう。
	物語には、正しい答えを導くために必要そうな要素をすべて盛り込もう

２．動かす。
	テストが宇部て通り、バーがグリーンになる状態への素早く到達する。
	きれいでシンプルが解が見えているなら、その通り書いてしまおう。
	もし実現に少し時間がかかりそうな場合は、
	一旦TODOリストに書いておき、目の前のバーを速やかにグリーンにする作業に戻る。
	なんでもいいからとにかく動かすという考え方は、
	優れたエンジニアリングのルールに反するようい感じるし、
	特にベテランの開発者にとっては、審美敵にも価値観的にも受け入れがたいかもしれない。
	それでも、素早いグリーンは全ての罪を赦す。
	ただし、赦されるのはほんの短い間だけだ。

３．正しくする。
	システムは動くまでは来たが、いろいろと汚い手を使ってしまった。
	悔い改め、ソフトウェアの正道を通り、
	書いてしまった重複を除去してグリーンバーに素早く戻ろう。

*/

/*

仮実装：コードでまずべた書きの値を使い、実装を進めるにしたがって、徐々に変数に置き換えていく
明白な実装：すぐに頭の中の実装をコードに落とす

私が普段TDDを行う時に２つの実装モードを揺れ動く。


*/
